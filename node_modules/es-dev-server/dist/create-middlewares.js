"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const koa_static_1 = tslib_1.__importDefault(require("koa-static"));
const koa_etag_1 = tslib_1.__importDefault(require("koa-etag"));
const koa_compress_1 = tslib_1.__importDefault(require("koa-compress"));
const chokidar_1 = tslib_1.__importDefault(require("chokidar"));
const base_path_1 = require("./middleware/base-path");
const history_api_fallback_1 = require("./middleware/history-api-fallback");
const compatibility_transform_1 = require("./middleware/compatibility-transform");
const watch_served_files_1 = require("./middleware/watch-served-files");
const polyfills_loader_1 = require("./middleware/polyfills-loader");
const message_channel_1 = require("./middleware/message-channel");
const etag_cache_1 = require("./middleware/etag-cache");
const response_body_cache_1 = require("./middleware/response-body-cache");
const setup_browser_reload_1 = require("./utils/setup-browser-reload");
const constants_1 = require("./constants");
const response_transform_1 = require("./middleware/response-transform");
const resolve_module_imports_1 = require("./utils/resolve-module-imports");
const compatibility_transform_2 = require("./utils/compatibility-transform");
const utils_1 = require("./utils/utils");
const defaultCompressOptions = {
    filter(contentType) {
        // event stream doesn't like compression
        return contentType !== 'text/event-stream';
    },
};
/**
 * Creates middlewares based on the given configuration. The middlewares can be
 * used by a koa server using `app.use()`:
 */
function createMiddlewares(config, fileWatcher = chokidar_1.default.watch([])) {
    const { appIndex, appIndexDir, babelExclude, babelModernExclude, babelModuleExclude, basePath, compatibilityMode, compress, customBabelConfig, customMiddlewares, responseTransformers, fileExtensions, nodeResolve, polyfillsLoaderConfig, readUserBabelConfig, rootDir, watch, logErrorsToBrowser, watchDebounce, } = config;
    const middlewares = [];
    middlewares.push((ctx, next) => {
        utils_1.logDebug(`Receiving request: ${ctx.url}`);
        return next();
    });
    if (compress) {
        const options = typeof compress === 'object' ? compress : defaultCompressOptions;
        middlewares.push(koa_compress_1.default(options));
    }
    if (!Object.values(constants_1.compatibilityModes).includes(compatibilityMode)) {
        throw new Error(`Unknown compatibility mode: ${compatibilityMode}. Must be one of: ${Object.values(constants_1.compatibilityModes)}`);
    }
    const setupCompatibility = customBabelConfig || compatibilityMode !== constants_1.compatibilityModes.NONE || readUserBabelConfig;
    const setupHistoryFallback = appIndex;
    const setupMessageChanel = watch || (logErrorsToBrowser && (setupCompatibility || nodeResolve));
    const resolveModuleImports = nodeResolve
        ? resolve_module_imports_1.createResolveModuleImports(rootDir, fileExtensions, typeof nodeResolve === 'boolean' ? undefined : nodeResolve)
        : undefined;
    const transformJs = setupCompatibility || nodeResolve
        ? compatibility_transform_2.createCompatibilityTransform({
            rootDir,
            readUserBabelConfig,
            nodeResolve,
            compatibilityMode,
            customBabelConfig,
            fileExtensions,
            babelExclude,
            babelModernExclude,
            babelModuleExclude,
        }, resolveModuleImports)
        : undefined;
    // strips a base path from requests
    if (basePath) {
        middlewares.push(base_path_1.createBasePathMiddleware({ basePath }));
    }
    // adds custom user's middlewares
    if (customMiddlewares && customMiddlewares.length > 0) {
        customMiddlewares.forEach(customMiddleware => {
            middlewares.push(customMiddleware);
        });
    }
    middlewares.push(async (ctx, next) => {
        await next();
        utils_1.logDebug(`Serving request: ${ctx.url} with status: ${ctx.status}`);
    });
    // serves 304 responses if resource hasn't changed
    middlewares.push(etag_cache_1.createEtagCacheMiddleware());
    // adds etag headers for caching
    middlewares.push(koa_etag_1.default());
    if (fileWatcher) {
        // caches (transformed) file contents for faster response times
        middlewares.push(response_body_cache_1.createResponseBodyCacheMiddleware({ fileWatcher, rootDir, fileExtensions }));
    }
    // communicates with browser for reload or logging
    if (setupMessageChanel) {
        middlewares.push(message_channel_1.createMessageChannelMiddleware({ rootDir, appIndex }));
    }
    // watches served files
    middlewares.push(watch_served_files_1.createWatchServedFilesMiddleware({
        rootDir,
        fileWatcher,
    }));
    // compile code using babel and/or resolve module imports
    if ((setupCompatibility || nodeResolve) && transformJs) {
        middlewares.push(compatibility_transform_1.createCompatibilityTransformMiddleware({
            rootDir,
            fileExtensions,
            transformJs,
        }));
    }
    // injects polyfills and shims for compatibility with older browsers
    if ((setupCompatibility || nodeResolve) && transformJs) {
        middlewares.push(polyfills_loader_1.createPolyfillsLoaderMiddleware({
            compatibilityMode,
            polyfillsLoaderConfig,
            rootDir,
            appIndex,
            transformJs,
        }));
    }
    // serves index.html for non-file requests for SPA routing
    if (setupHistoryFallback && typeof appIndex === 'string' && typeof appIndexDir === 'string') {
        middlewares.push(history_api_fallback_1.createHistoryAPIFallbackMiddleware({ appIndex, appIndexDir }));
    }
    if (watch) {
        setup_browser_reload_1.setupBrowserReload({ fileWatcher, watchDebounce });
    }
    if (responseTransformers) {
        middlewares.push(response_transform_1.createResponseTransformMiddleware({ responseTransformers }));
    }
    // serve sstatic files
    middlewares.push(koa_static_1.default(rootDir, {
        hidden: true,
        setHeaders(res) {
            res.setHeader('cache-control', 'no-cache');
        },
    }));
    return middlewares;
}
exports.createMiddlewares = createMiddlewares;
//# sourceMappingURL=create-middlewares.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const strip_ansi_1 = tslib_1.__importDefault(require("strip-ansi"));
const utils_1 = require("../utils/utils");
const message_channel_1 = require("../utils/message-channel");
const resolve_module_imports_1 = require("../utils/resolve-module-imports");
const user_agent_compat_1 = require("../utils/user-agent-compat");
function logError(errorMessage) {
    // strip babel ansi color codes because they're not colored correctly for the browser terminal
    message_channel_1.sendMessageToActiveBrowsers('error-message', JSON.stringify(strip_ansi_1.default(errorMessage)));
    /* eslint-disable-next-line no-console */
    console.error(`\n${errorMessage}`);
}
/**
 * Sets up a middleware which runs all served js code through babel. Different babel configs
 * are loaded based on the server's configuration.
 */
function createCompatibilityTransformMiddleware(cfg) {
    return async function compatibilityMiddleware(ctx, next) {
        const baseURL = ctx.url.split('?')[0].split('#')[0];
        if (utils_1.isPolyfill(ctx.url) || !cfg.fileExtensions.some(ext => baseURL.endsWith(ext))) {
            return next();
        }
        if (ctx.headers.accept.includes('text/html')) {
            return next();
        }
        await next();
        // should be a 2xx response
        if (ctx.status < 200 || ctx.status >= 300) {
            return undefined;
        }
        const transformModule = utils_1.shoudlTransformToModule(ctx.url);
        const filePath = utils_1.getRequestFilePath(ctx, cfg.rootDir);
        // if there is no file path, this file was not served statically
        if (!filePath) {
            return undefined;
        }
        // Ensure we respond with js content type
        ctx.response.set('content-type', 'text/javascript');
        try {
            const code = await utils_1.getBodyAsString(ctx);
            const uaCompat = user_agent_compat_1.getUserAgentCompat(ctx);
            const transformedCode = await cfg.transformJs({
                uaCompat,
                filePath,
                code,
                transformModule,
            });
            ctx.body = transformedCode;
            ctx.status = 200;
            return undefined;
        }
        catch (error) {
            if (error instanceof utils_1.RequestCancelledError) {
                return undefined;
            }
            // ResolveSyntaxError is thrown when resolveModuleImports runs into a syntax error from
            // the lexer, but babel didn't see any errors. this means either a bug in the lexer, or
            // some experimental syntax. log a message and return the module untransformed to the
            // browser
            if (error instanceof resolve_module_imports_1.ResolveSyntaxError) {
                logError(`Could not resolve module imports in ${ctx.url}: Unable to parse the module, this can be due to experimental syntax or a bug in the parser.`);
                return undefined;
            }
            utils_1.logDebug(error);
            let errorMessage = error.message;
            // replace babel error messages file path with the request url for readability
            if (errorMessage.startsWith(filePath)) {
                errorMessage = errorMessage.replace(filePath, ctx.url);
            }
            errorMessage = `Error compiling: ${errorMessage}`;
            // send compile error to browser for logging
            ctx.body = errorMessage;
            ctx.status = 500;
            logError(errorMessage);
        }
        return undefined;
    };
}
exports.createCompatibilityTransformMiddleware = createCompatibilityTransformMiddleware;
//# sourceMappingURL=compatibility-transform.js.map